###演示形参本质上是实参的一个值拷贝，而且形参是在栈上分配的，和实参在内存中物理层面不是一个位置；
[重点： 
要想用指针传递参数，通过函数改变主函数中字符串指针变量的值，必须使用char**，也就是二级指针。
因为C语言函数总是接收参数的副本，函数接收的都是参数副本。]



###### 3.1 错误示范(通过函数改变主函数中字符串指针变量的值)
先举个例子
```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void func(char* dst) {
        char* buf = (char*)malloc(20);
        memset(buf, 0, 20);
        strcpy(buf, "hello world!");
        dst = buf;
        puts(dst);
}

int main() {
        char* s = "123456";
        func(s);
        puts(s);
        return 0;
}
/*
本来想通过func函数改变s的值，结果并没有改变，还是输出123456
*/
```

因为以前值传递和指针传递时用的例子是整型变量，参数传递时用一级指针就可以通过函数改变主函数中的变量的值。 
换成字符串变量，咋一看也是一级指针，但是你要明白，字符串指针的本质是什么？
char* s； char* 本来就仅仅是一个字符串指针变量的类型！ s存的是一个字符串的首地址值(第一个字节)，
所以你要通过函数改变字符串指针变量的值，就得用 char** 二级指针！
[因为C语言的函数总是接收参数的副本，请必须理解这句话，那么你就理解了上面这段话]



###### 3.2 正确姿势(通过函数改变主函数中字符串指针变量的值)
```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void func(char **dst) {
    char *buf = (char *) malloc(20);
    memset(buf, 0, 20);
    strcpy(buf, "hello world!");
    *dst = buf;
    puts(*dst);
}

int main() {
    char *s = "123456";
    func(&s);
    puts(s);
    return 0;
}
```

###### 3.3 特殊情况(通过函数改变主函数中字符串指针变量的值)（深刻理解---*解指针的含义）
```c
#include <stdio.h>

void func1(char *dst) {
    *dst = 'c';
}

void func2(char *dst) {
    *dst = 'c';
}


int main() {
    ////////////////////////////////////////////////////////////
    /// char* s22 = "123"; //对于这样声明的字符创，编译器会自动在末位加上'\0'
    /// func2(s22); //将会报错，段错误，因为这样声明的是一个字符串常量(在内存的常量区)，只可读，禁止写；
    /// puts(s22);

    ////////////////////////////////////////////////////////////
    char s11[] = {'1', '2', '3', '\0'};
    func1(s11); //可以将s11指向的内存区域，第一个字节，修改为'c'，因为数组的声明方式不是存储在内存中的常量区;
    puts(s11); //打印结果：c23
    return 0;
}
```